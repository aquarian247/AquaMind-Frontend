# Frontend Adaptation Principles  
_AquaMind ‚Ä¢ React + TypeScript_  

These principles are **non-negotiable** and keep the AquaMind frontend in permanent lock-step with the backend API contract.

---

## 1‚ÄÉBackend Is Frozen ‚Äì Single Source of Truth  
* The OpenAPI document (`api/openapi.yaml`) generated by **drf-spectacular** defines the contract.  
* Serializer / field names, URL shapes and enums **will not be aliased** for the UI.  
* All divergence must be resolved on the frontend side.

**Anti-pattern**  
‚ùå _‚ÄúLet‚Äôs add a `totalBiomass` alias to the serializer so the dashboard is easier.‚Äù_

---

## 2‚ÄÉUse Auto-Generated Types Only  
* DTOs are produced by CI via **openapi-typescript-codegen** and live under  
  `client/src/api/generated/`.  
* **Never** create parallel or ‚Äúextended‚Äù interfaces that shadow these models.  
* View-model layers may wrap generated types but must not duplicate API fields.

```ts
// ‚úÖ Good ‚Äì import canonical model
import { FeedingEvent } from "@/api/generated/models/FeedingEvent";

// ‚ùå Bad ‚Äì local duplicate
interface FeedingEvent { feeding_date: string; amount_kg: number; }
```

---

## 3‚ÄÉEmbrace `snake_case` Directly  
* Components, hooks and utils reference backend field names **verbatim**.  
* No mapping or camelCase transformation layer is permitted ‚Äì it hides drift.

```tsx
// ‚úÖ Correct ‚Äì uses snake_case
row.original.feeding_date

// ‚ùå Wrong ‚Äì camelCase that doesn‚Äôt exist
row.original.feedingDate
```

### Why no transformation layer?
1. Eliminates hidden mapping bugs.  
2. Code matches API docs exactly ‚Üí faster onboarding.  
3. Keeps generated types usable out-of-the-box.

---

## 4‚ÄÉCompute Properties Client-Side by Default  
* KPI tiles and summary metrics are calculated in React hooks (`use‚Ä¶`) or
  TanStack Query `select` callbacks.  
* Request **raw data**, derive metrics locally _unless_ **all** three conditions hold:  

| Condition | Example |
|-----------|---------|
| Heavy DB join / time-series window | Company-wide FCR over 3 years |
| Payload volume impractical | Millions of sensor rows |
| Same aggregation needed by other clients | Mobile app, BI export |

If a calculation meets these conditions, raise a **Backend RFC**; otherwise compute in the browser.

```ts
// client aggregation example
const averageWeight = useMemo(
  () => samples.reduce((s, v) => s + Number(v.avg_weight_g), 0) / samples.length,
  [samples]
);
```

---

## 5‚ÄÉPhase-Based Implementation for AI Agents  
Progress is tracked by **phases**, not wall-clock time.  

| Phase | Exit Criteria | Typical Owner |
|-------|---------------|---------------|
| P0 ‚Äî Type Purge | No local DTO files remain | Code Droid |
| P1 ‚Äî Snake_Case Adoption | No camelCase data props | Code Droid |
| P2 ‚Äî ApiService Only | No literal `/api` strings or `fetch()` | Code Droid |
| P3 ‚Äî Client Aggregations | `npm run type-check` passes (0 errors) | Code Droid |
| P4 ‚Äî Reliability Gate | CI type-check & endpoint validator blocking | Reliability Droid |

Droids update `docs/api_alignment/API_TYPE_ALIGNMENT_MASTER_PLAN.md` after each session.

---

## Quick-Check Checklist  

- [ ] Import path starts with `@/api/generated/`  
- [ ] Field names are snake_case  
- [ ] No `any` casts hiding contract errors  
- [ ] Aggregations live in hooks, not serializers  
- [ ] CI (`npm run type-check` + endpoint validator) green

Follow these rules and the contract will never drift. üêü
