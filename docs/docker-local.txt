### Step-by-Step Guide to Containerizing and Deploying AquaMind with GitHub CI/CD

Hey! Sounds like a solid stability milestone for AquaMindâ€”congrats on getting it running locally. Since you're starting with the [LOCAL_VLAN_SETUP.md](https://github.com/aquarian247/AquaMind-Frontend/blob/main/docs/LOCAL_VLAN_SETUP.md) guide today, that's a great way to dip into networked local runs (likely involving Docker Compose for frontend-backend-DB isolation on a virtual LAN). I'll build on that assumption and outline how to evolve your setup into containerized apps, GitHub Actions for CI/testing/package building, and deployment to Ubuntu VMs for test/prod.

I'll keep this practical: focus on Docker for the Node frontend and Django backend, Postgres (assuming that's your DB; swap if not) on the VM host, and GitHub Actions to automate testing/builds. This assumes separate repos for frontend and backend (common for Node/Django stacks)â€”if it's monorepo, adapt accordingly. We'll use GitHub Container Registry (GHCR) for free image hosting.

#### 1. **Containerize Your Apps (Prep for Local Testing and CI)**
   Start here to replicate your local runs in Docker. This makes everything portable and aligns with the VLAN setup (which probably uses Docker networks for inter-app communication).

   - **Prerequisites:**
     - Install Docker and Docker Compose on your Mac (via Docker Desktop).
     - Ensure your apps have env vars for prod-like configs (e.g., `.env` files ignored in `.gitignore`).
     - For backend: Run `python manage.py collectstatic` in builds; use Gunicorn/Waitress for serving (not dev server).

   - **Frontend (Node App) Dockerfile:**
     Create `Dockerfile` in your frontend repo root:
     ```
     FROM node:20-alpine AS builder
     WORKDIR /app
     COPY package*.json ./
     RUN npm ci --only=production
     COPY . .
     RUN npm run build  # Assuming you have a build script for prod assets

     FROM nginx:alpine
     COPY --from=builder /app/dist /usr/share/nginx/html  # Adjust if your build outputs to /dist
     COPY nginx.conf /etc/nginx/conf.d/default.conf  # Optional: Custom Nginx config for proxying API calls
     EXPOSE 80
     CMD ["nginx", "-g", "daemon off;"]
     ```
     - Build/test locally: `docker build -t aquamind-frontend .`
     - Run: `docker run -p 3000:80 aquamind-frontend`

   - **Backend (Django App) Dockerfile:**
     Create `Dockerfile` in your backend repo root:
     ```
     FROM python:3.12-slim
     WORKDIR /app
     ENV PYTHONDONTWRITEBYTECODE=1 PYTONUNBUFFERED=1
     COPY requirements.txt ./
     RUN pip install --no-cache-dir -r requirements.txt
     COPY . .
     RUN python manage.py collectstatic --noinput
     RUN python manage.py migrate  # Run migrations in build if schema is stable

     FROM gunicorn:22  # Or use waitress if preferred
     WORKDIR /app
     COPY --from=0 /app /app
     CMD ["gunicorn", "--bind", "0.0.0.0:8000", "yourproject.wsgi:application"]  # Replace 'yourproject'
     EXPOSE 8000
     ```
     - Build/test: `docker build -t aquamind-backend .`
     - Run: `docker run -p 8000:8000 -e DATABASE_URL=... aquamind-backend` (pass DB creds via env).

   - **Local VLAN Setup with Docker Compose:**
     Extend the guide you're trying: Create `docker-compose.yml` in a shared dir (or per-repo) for networked runs mimicking VLAN.
     ```
     version: '3.8'
     services:
       frontend:
         build: ./frontend  # Path to frontend dir
         ports:
           - "3000:80"
         networks:
           - aquamind-vlan
         depends_on:
           - backend

       backend:
         build: ./backend  # Path to backend dir
         ports:
           - "8000:8000"
         environment:
           - DATABASE_URL=postgresql://user:pass@db:5432/aquamind  # Internal DB connect
         networks:
           - aquamind-vlan
         depends_on:
           - db

       db:  # For local dev; skip in prod VMs
         image: postgres:16
         environment:
           POSTGRES_DB: aquamind
           POSTGRES_USER: user
           POSTGRES_PASSWORD: pass
         volumes:
           - postgres_data:/var/lib/postgresql/data
         ports:
           - "5432:5432"
         networks:
           - aquamind-vlan

     volumes:
       postgres_data:

     networks:
       aquamind-vlan:
         driver: bridge  # Simulates VLAN isolation
     ```
     - Run: `docker-compose up -d`. Frontend proxies API calls to backend via internal network (e.g., `http://backend:8000`).
     - Test: Curl backend endpoints, hit frontend UI. This teaches VLAN-like isolation before VM deploys.

   - **DB Note:** You're rightâ€”DBs in containers work great for dev/test (with volumes for persistence), but for prod, running Postgres directly on the Ubuntu VM host avoids container overhead and simplifies backups/snapshots. Use Docker for apps only.

#### 2. **Set Up GitHub Actions for CI (Testing) and Packaging (Builds)**
   GitHub Actions will run tests on push/PR, build Docker images, and push them to GHCR as "deployment packages." Tag images with commit/SHA for versioning.

   - **Enable GHCR:** Go to repo Settings > Packages > Enable "Package and publish to GitHub Packages."
   - **Secrets:** In repo Settings > Secrets and variables > Actions, add:
     - `DOCKER_USERNAME`: Your GitHub username.
     - `DOCKER_PASSWORD`: A Personal Access Token (classic, with `write:packages` scope).

   - **Frontend Workflow (`.github/workflows/ci-cd.yml`):**
     ```
     name: CI/CD Frontend
     on:
       push:
         branches: [main, develop]
       pull_request:
         branches: [main]

     jobs:
       test:
         runs-on: ubuntu-latest
         steps:
           - uses: actions/checkout@v4
           - uses: actions/setup-node@v4
             with:
               node-version: 20
           - run: npm ci
           - run: npm test  # Assuming you have tests (Jest/Vitest)
           - run: npm run build

       build-push:
         needs: test
         runs-on: ubuntu-latest
         if: github.ref == 'refs/heads/main'  # Only on main for prod packages
         steps:
           - uses: actions/checkout@v4
           - name: Build and push Docker image
             uses: docker/build-push-action@v5
             with:
               context: .
               push: true
               tags: ghcr.io/${{ github.repository }}:latest, ghcr.io/${{ github.repository }}:${{ github.sha }}
               # Auth happens via GITHUB_TOKEN
     ```

   - **Backend Workflow (Similar, in backend repo):**
     ```
     name: CI/CD Backend
     on:
       push:
         branches: [main, develop]
       pull_request:
         branches: [main]

     jobs:
       test:
         runs-on: ubuntu-latest
         services:
           db:  # Spin up test DB
             image: postgres:16
             env:
               POSTGRES_DB: test_aquamind
               POSTGRES_PASSWORD: testpass
             options: >-
               --health-cmd pg_isready
               --health-interval 10s
               --health-timeout 5s
               --health-retries 5
         steps:
           - uses: actions/checkout@v4
           - uses: actions/setup-python@v5
             with:
               python-version: '3.12'
           - run: pip install -r requirements.txt
           - run: python manage.py test  # Django tests
           - run: python manage.py migrate
           - run: python manage.py collectstatic --noinput

       build-push:
         needs: test
         runs-on: ubuntu-latest
         if: github.ref == 'refs/heads/main'
         steps:
           - uses: actions/checkout@v4
           - name: Build and push Docker image
             uses: docker/build-push-action@v5
             with:
               context: .
               push: true
               tags: ghcr.io/${{ github.repository_owner }}/aquamind-backend:latest, ghcr.io/${{ github.repository_owner }}/aquamind-backend:${{ github.sha }}
     ```
     - **How it works:** Tests run on every change. On `main` pushes, it builds/pushes images (e.g., `ghcr.io/aquarian247/aquamind-frontend:latest`). Use `develop` branch for test deploys.
     - Pro tip: Add linting (e.g., `npm run lint`, `flake8`) and security scans (e.g., `docker scout` action) to the test job.

#### 3. **Deploy to Ubuntu VMs (Test/Prod Environments)**
   Provision Ubuntu VMs (e.g., via AWS EC2, DigitalOcean, or local Proxmox). One VM per env (test/prod), with DB on host.

   - **VM Setup (One-Time):**
     - SSH in: `sudo apt update && sudo apt install docker.io docker-compose postgresql postgresql-contrib -y`
     - Start/enable services: `sudo systemctl enable --now docker postgresql`
     - Create DB: `sudo -u postgres psql -c "CREATE DATABASE aquamind; CREATE USER aquamind_user WITH PASSWORD 'strongpass'; GRANT ALL ON DATABASE aquamind TO aquamind_user;"`
     - Firewall: `sudo ufw allow 80,443,3000,8000` (adjust ports).
     - Docker login for GHCR: `echo $TOKEN | docker login ghcr.io -u USERNAME --password-stdin` (use a script or systemd).

   - **Deployment Script (`deploy.sh` on VMâ€”Run Manually or via GitHub Actions):**
     ```
     #!/bin/bash
     ENV=$1  # 'test' or 'prod'
     REGISTRY=ghcr.io/aquarian247  # Your GHCR

     # Pull images (use :latest for prod, :sha for test)
     TAG=${ENV}_latest  # Or fetch latest SHA from GH API
     docker pull $REGISTRY/aquamind-frontend:$TAG
     docker pull $REGISTRY/aquamind-backend:$TAG

     # Stop old containers
     docker stop aquamind-frontend aquamind-backend || true
     docker rm aquamind-frontend aquamind-backend || true

     # Run backend (connect to host DB)
     docker run -d --name aquamind-backend \
       -p 8000:8000 \
       -e DATABASE_URL=postgresql://aquamind_user:strongpass@localhost:5432/aquamind \
       -e SECRET_KEY=your_django_secret \
       $REGISTRY/aquamind-backend:$TAG

     # Run frontend (proxy to backend)
     docker run -d --name aquamind-frontend \
       -p 80:80 \
       -e REACT_APP_API_URL=http://localhost:8000/api  # Internal proxy via Nginx
       $REGISTRY/aquamind-frontend:$TAG

     # Health check
     curl -f http://localhost || echo "Deploy failed!"
     ```
     - Run: `chmod +x deploy.sh && ./deploy.sh test`
     - For VLAN-like isolation on VM: Use Docker networks (`docker network create aquamind-vlan`) and attach containers.

   - **Automate Deploys (Optional Advanced):**
     - GitHub Actions deploy job: Add SSH action (e.g., `appleboy/ssh-action`) to run `deploy.sh` on VM after build-push. Store VM IP/SSH key as secrets.
     - Or use tools like Ansible: Playbook to pull/run on VMs.
     - Monitoring: Add Prometheus or just `docker logs` cron jobs.

#### Next Steps & Tips
- **Today:** Finish LOCAL_VLAN_SETUP.md, then build/test the Dockerfiles locally with Compose. Commit/push to trigger your first CI run.
- **Branching:** Use `develop` for test deploys, `main` for prod.
- **Security:** Scan images (`docker scan`), use multi-stage builds to slim them down, and rotate secrets.
- **Scaling:** If traffic grows, add Traefik/NGINX reverse proxy on VM for HTTPS/load balancing.
- **Costs:** GH Actions free for public repos; VMs start ~$5/mo.

If the VLAN guide has specifics (e.g., custom ports/networks) that clash, share details for tweaks. Or if you hit snags with the backend repo setup, lmkâ€”happy to refine! ðŸš€